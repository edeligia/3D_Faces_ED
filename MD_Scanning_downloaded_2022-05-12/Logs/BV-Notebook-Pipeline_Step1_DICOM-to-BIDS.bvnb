{
    "bvnbformat": 1,
    "bvnbformat_minor": 0,
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "# BV Notebook Pipeline, Step 1: DICOM to BIDS (November 11, 2020)\n",
                "## Overview\n",
                "Anonymizes DICOMS and then loads them into BIDS configuration."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "## Parameters + Setup\n",
                "\n",
                "Set parameters and perform setup.\n",
                "\n",
                "Required to run any other cell."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 64,
            "metadata": {
            },
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "Subjects and runs to process:\n",
                        "\tsub-01 = 2021_10_18_3D_OT08\n",
                        "\t\tanatomical series  = 09\n",
                        "\t\tfunc run 01 series = 06\n",
                        "\t\tfunc run 02 series = 12\n",
                        "Preparations complete. You can now run any of the later cells."
                    ]
                }
            ],
            "source": [
                "#do not change these 3 lines\n",
                "import numpy as np\n",
                "import os.path as path\n",
                "import glob, ntpath, shutil\n",
                "\n",
                "########################################################################################################\n",
                "######################################## Parameters (edit here) ########################################\n",
                "########################################################################################################\n",
                "\n",
                "########## Directories ##########\n",
                "\n",
                "# must use / regardless of operating system (not \\)\n",
                "# output directories will be created if they do not already exist\n",
                "\n",
                "# input - folder with all DICOMs (can be in subdirectories)\n",
                "DIRECTORY_INPUT_DICOM = 'C:/Users/CulhamLabTR/Desktop/Marisa/Dicoms/PIL04 - 20211018/2021_10_18_3D_OT08'\n",
                "\n",
                "# input - folder with all PRT or TSV (can be in subdirectories)\n",
                "DIRECTORY_INPUT_EVENTS = 'C:/Users/CulhamLabTR/Desktop/Marisa/Dicoms/PIL04 - 20211018/PRTS'\n",
                "\n",
                "# output - anonymized DICOMs\n",
                "DIRECTORY_OUTPUT_DICOM = 'C:/Users/CulhamLabTR/Desktop/Marisa/Dicoms/PIL04 - 20211018/DICOM_Anon'\n",
                "\n",
                "# output - renamed PRT (or TSV)\n",
                "DIRECTORY_OUTPUT_EVENTS = 'C:/Users/CulhamLabTR/Desktop/Marisa/Dicoms/PIL04 - 20211018/PRT_Anon'\n",
                "\n",
                "# output - BIDS\n",
                "DIRECTORY_OUTPUT_BIDS = 'C:/Users/CulhamLabTR/Desktop/Marisa/Dicoms/PIL04 - 20211018/BIDS'\n",
                "\n",
                "\n",
                "\n",
                "########## General ##########\n",
                "\n",
                "# removes the face in anatomical DICOM files (for external sharing)\n",
                "# NOTE: cannot currently be automated in notebook but will be added later. For now, manual steps are outlined in a cell below.\n",
                "DEFACE_ANAT = True\n",
                "\n",
                "# check the number of files in each series, throws an exception (stops) if there is a mismatch\n",
                "# set to -1 to skip this check\n",
                "EXPECTED_NUMBER_FILES_ANAT = 192\n",
                "EXPECTED_NUMBER_FILES_FUNC = -1\n",
                "\n",
                "# number of participants/runs, can be set higher than needed\n",
                "MAX_NUMBER_PARTICIPANTS = 1;\n",
                "MAX_NUMBER_RUNS = 2;\n",
                "\n",
                "# name of the task to include in BIDS filenames\n",
                "TASK_NAME = 'Loc'\n",
                "\n",
                "# typically, an exception would be thrown (stops) if a functional run has DICOMs but no PRT/TSV\n",
                "# set False to allow missing orders (resulting BIDS will not have orders for those runs)\n",
                "REQUIRE_FUNC_EVENTS = False\n",
                "\n",
                "\n",
                "\n",
                "########## Participant Mapping ##########\n",
                "\n",
                "#Note: can use either PRT or TSV\n",
                "\n",
                "#do not change these 4 lines\n",
                "PAR_ID          = [\"\" for x in range(MAX_NUMBER_PARTICIPANTS)]\n",
                "PAR_SERIES_ANAT = np.full(MAX_NUMBER_PARTICIPANTS, -1)\n",
                "PAR_SERIES_FUNC = np.full((MAX_NUMBER_PARTICIPANTS, MAX_NUMBER_RUNS), -1)\n",
                "PAR_EVENT_FILENAMES   = [[-1 for r in range(MAX_NUMBER_RUNS)] for p in range(MAX_NUMBER_PARTICIPANTS)]\n",
                "\n",
                "# EXAMPLE:\n",
                "#    mapping to BIDS sub-04\n",
                "#    ID was 2020_10_01_AB12\n",
                "#    anatomical was series 2\n",
                "#    functional\n",
                "#        run 1 was series 10\n",
                "#        run 2 was series 11\n",
                "#        run 3 was invalid/excluded/etc\n",
                "#        run 4 was series 13\n",
                "#        run 5-10 don't exist\n",
                "#    protocols\n",
                "#        named \"AB12_run#.prt\"\n",
                "#BIDS_sub_num = 4\n",
                "#PAR_ID[BIDS_sub_num-1]          = '2020_10_01_AB12'\n",
                "#PAR_SERIES_ANAT[BIDS_sub_num-1] = 2\n",
                "#PAR_SERIES_FUNC[BIDS_sub_num-1] = [10, 11, -1, 13, -1, -1, -1, -1, -1, -1] #must match MAX_NUMBER_RUNS\n",
                "#PAR_EVENT_FILENAMES[BIDS_sub_num-1]   = [f\"AB12_run{r}.prt\" for r in range(1,MAX_NUMBER_RUNS+1)] #option 1: code\n",
                "#PAR_EVENT_FILENAMES[BIDS_sub_num-1]   = ['AB12_run1.prt', 'AB12_run2.prt', -1, 'AB12_run4.prt', -1, -1, -1, -1, -1, -1] #option 2: explicit\n",
                "\n",
                "#add each participant here...\n",
                "\n",
                "\n",
                "#mapping to BIDS sub-01\n",
                "#   ID was 2021_09_03_3DOM30\n",
                "#    anatomical was series 2\n",
                "#    functional\n",
                "#        run 1 was series 9\n",
                "#        run 2 was series 10\n",
                "#        run 3 was series 11\n",
                "#        run 4 was series 15\n",
                "#        run 5 was series 16\n",
                "#        run 6-8 don't exist\n",
                "#    protocols\n",
                "#        named \"3Dfaces_FaceOrder#.prt\"\n",
                "BIDS_sub_num = 1\n",
                "PAR_ID[BIDS_sub_num-1]          = '2021_10_18_3D_OT08'\n",
                "PAR_SERIES_ANAT[BIDS_sub_num-1] = 9\n",
                "PAR_SERIES_FUNC[BIDS_sub_num-1] = [6,12] #must match MAX_NUMBER_RUNS\n",
                "PAR_EVENT_FILENAMES[BIDS_sub_num-1]   = [f\"3Dfaces_LocOrder{r}.prt\" for r in range(1,MAX_NUMBER_RUNS+1)] #option 1: code\n",
                "#PAR_EVENT_FILENAMES[BIDS_sub_num-1]   = ['3Dfaces_FaceOrder2.prt', '3Dfaces_FaceOrder3.prt', '3Dfaces_FaceOrder4.prt', '3Dfaces_FaceOrder5.prt', '3Dfaces_FaceOrder6.prt', '3Dfaces_FaceOrder7.prt','3Dfaces_FaceOrder8.prt', '3Dfaces_FaceOrder1.prt'] #option 2: explicit\n",
                "\n",
                "\n",
                "\n",
                "\n",
                "\n",
                "\n",
                "\n",
                "########################################################################################################\n",
                "######################################## Do not edit below here ########################################\n",
                "########################################################################################################\n",
                "\n",
                "######################################## Check Directories ########################################\n",
                "\n",
                "#directories must end in filesep\n",
                "if DIRECTORY_INPUT_DICOM[-1] != '/':\n",
                "    DIRECTORY_INPUT_DICOM += '/'\n",
                "if DIRECTORY_INPUT_EVENTS[-1] != '/':\n",
                "    DIRECTORY_INPUT_EVENTS += '/'\n",
                "if DIRECTORY_OUTPUT_DICOM[-1] != '/':\n",
                "    DIRECTORY_OUTPUT_DICOM += '/'\n",
                "if DIRECTORY_OUTPUT_EVENTS[-1] != '/':\n",
                "    DIRECTORY_OUTPUT_EVENTS += '/'\n",
                "if DIRECTORY_OUTPUT_BIDS[-1] != '/':\n",
                "    DIRECTORY_OUTPUT_BIDS += '/'\n",
                "    \n",
                "#dicom directories must be different\n",
                "if DIRECTORY_INPUT_DICOM == DIRECTORY_OUTPUT_DICOM:\n",
                "    raise Exception(f\"DICOM input and output directories must be different\")\n",
                "\n",
                "#event directories must be different\n",
                "if DIRECTORY_INPUT_EVENTS == DIRECTORY_OUTPUT_EVENTS:\n",
                "    raise Exception(f\"DICOM input and output directories must be different\")\n",
                "\n",
                "#dicom dir must exist\n",
                "if not path.isdir(DIRECTORY_INPUT_DICOM):\n",
                "    raise Exception(f\"DICOM input directory does not exist: {DIRECTORY_INPUT_DICOM}\")\n",
                "    \n",
                "#event dir should exist unless not REQUIRE_FUNC_EVENTS\n",
                "if path.isdir(DIRECTORY_INPUT_EVENTS):\n",
                "    CHECK_EVENTS = True\n",
                "else:\n",
                "    if REQUIRE_FUNC_EVENTS:\n",
                "        raise Exception(f\"Event input directory does not exist and events are set to required: {DIRECTORY_INPUT_EVENTS}\")\n",
                "    else:\n",
                "        print(f\"WARNING: Event input directory does not exist but events are NOT set to required so events will NOT be linked for any runs: {DIRECTORY_INPUT_EVENTS}\")\n",
                "        CHECK_EVENTS = False\n",
                "\n",
                "######################################## Generate Names ########################################\n",
                "\n",
                "#BIDS participant names\n",
                "PAR_NAMES = [f\"sub-{par:02}\" for par in range(1,MAX_NUMBER_PARTICIPANTS+1)]\n",
                "\n",
                "#output dicom subdirectories\n",
                "SUBDIR_DICOM_ANAT = [f\"{DIRECTORY_OUTPUT_DICOM}{PAR_NAMES[par]}/anat/\" for par in range(0,MAX_NUMBER_PARTICIPANTS)]\n",
                "SUBDIR_DICOM_FUNC = [[f\"{DIRECTORY_OUTPUT_DICOM}{PAR_NAMES[par]}/func{r}/\" for r in range(1,MAX_NUMBER_RUNS+1)] for par in range(0,MAX_NUMBER_PARTICIPANTS)]\n",
                "\n",
                "#renamed event filepaths\n",
                "FILEPATH_EVENT_ANON = [[f\"{DIRECTORY_OUTPUT_EVENTS}{PAR_NAMES[par]}_ses-01_task-{TASK_NAME}_run-{r}\" for r in range(1,MAX_NUMBER_RUNS+1)] for par in range(0,MAX_NUMBER_PARTICIPANTS)]\n",
                "for par in range(0, MAX_NUMBER_PARTICIPANTS):\n",
                "    for run in range(0, MAX_NUMBER_RUNS):\n",
                "        type = \"prt\"\n",
                "        if isinstance(PAR_EVENT_FILENAMES[par][run], str):\n",
                "            if len(PAR_EVENT_FILENAMES[par][run]) > 3:\n",
                "                type = PAR_EVENT_FILENAMES[par][run][-3:]\n",
                "        FILEPATH_EVENT_ANON[par][run] += \".\" + type\n",
                "\n",
                "\n",
                "######################################## Check Series to Run ########################################\n",
                "\n",
                "#which participants/runs to do\n",
                "PAR_TO_DO = np.full((MAX_NUMBER_PARTICIPANTS),False)\n",
                "ANAT_TO_DO = np.full((MAX_NUMBER_PARTICIPANTS),False)\n",
                "FUNC_TO_DO = np.full((MAX_NUMBER_PARTICIPANTS,MAX_NUMBER_RUNS),False)\n",
                "for par in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "    if (len(PAR_ID[par]) > 0):\n",
                "        ANAT_TO_DO[par] = PAR_SERIES_ANAT[par] > 0\n",
                "        FUNC_TO_DO[par] = PAR_SERIES_FUNC[par] > 0\n",
                "        if (ANAT_TO_DO[par] | any(FUNC_TO_DO[par])):\n",
                "            PAR_TO_DO[par] = True\n",
                "        \n",
                "#at least one anat or func run to do?\n",
                "if not any(PAR_TO_DO):\n",
                "    raise Exception(\"No anatomical or functional series have been entered!\")\n",
                "    \n",
                "#set of series per participant (anat and func together)\n",
                "SERIES_TO_DO = [np.append(PAR_SERIES_ANAT[par], PAR_SERIES_FUNC[par]) for par in range(0,MAX_NUMBER_PARTICIPANTS)]            #all possible sets\n",
                "SERIES_TO_DO = [SERIES_TO_DO[par][np.append(ANAT_TO_DO[par],FUNC_TO_DO[par])] for par in range(0,MAX_NUMBER_PARTICIPANTS)]    #remove excluded sets\n",
                "SERIES_TO_DO_COUNT = [len(SERIES_TO_DO[par]) for par in range(MAX_NUMBER_PARTICIPANTS)]     \n",
                "SERIES_TO_DO_IS_ANAT = [(SERIES_TO_DO[par] == PAR_SERIES_ANAT[par]) for par in range(0,MAX_NUMBER_PARTICIPANTS)]       \n",
                "SERIES_TO_DO_RUN = [[np.select(PAR_SERIES_FUNC[par] == series, range(0, MAX_NUMBER_RUNS), -1) for series in SERIES_TO_DO[par]] for par in range(0,MAX_NUMBER_PARTICIPANTS)]    \n",
                "\n",
                "#warn if any participants have anat without func or vice versa\n",
                "for par in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "    if (ANAT_TO_DO[par] & (any(FUNC_TO_DO[par]) == False)):\n",
                "        print(f\"WARNING: {PAR_NAMES[par]} has a series for anatomical but not for any functional runs\")\n",
                "    elif ((ANAT_TO_DO[par] == False) & any(FUNC_TO_DO[par])):\n",
                "        print(f\"WARNING: {PAR_NAMES[par]} has one or more series for functional runs but no series for anatomical\")\n",
                "\n",
                "#check for duplicate IDs\n",
                "for p1 in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "    if PAR_TO_DO[p1]:\n",
                "        for p2 in range(p1+1,MAX_NUMBER_PARTICIPANTS):\n",
                "            if PAR_TO_DO[p2]:\n",
                "                if PAR_ID[p1] == PAR_ID[p2]:\n",
                "                    raise Exception(f\"{PAR_NAMES[p1]} and {PAR_NAMES[p2]} have the same ID: {PAR_ID[p1]}\")\n",
                "\n",
                "#check for duplicate series within each participant\n",
                "for par in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "    if PAR_TO_DO[par]:\n",
                "        if len(np.unique(SERIES_TO_DO[par])) != len(SERIES_TO_DO[par]):\n",
                "            raise Exception(f\"{PAR_NAMES[par]} contains duplicate series\")\n",
                "\n",
                "######################################## Functions ########################################\n",
                "\n",
                "def GetDICOMS(par, run, is_anat, is_input, is_anon, is_defaced):\n",
                "    #directory to look in\n",
                "    if is_input:\n",
                "        directory = DIRECTORY_INPUT_DICOM + \"**/\" #recursive\n",
                "    else:\n",
                "        if is_anat:\n",
                "            directory = SUBDIR_DICOM_ANAT[par]\n",
                "        else:\n",
                "            directory = SUBDIR_DICOM_FUNC[par][run]\n",
                "\n",
                "    #prefix if defaced\n",
                "    if is_defaced:\n",
                "        prefix = \"defaced_\"\n",
                "    else:\n",
                "        prefix = \"\";\n",
                "    \n",
                "    #ID\n",
                "    if is_anon:\n",
                "        ID = PAR_NAMES[par]\n",
                "    else:\n",
                "        ID = PAR_ID[par]\n",
                "        \n",
                "    #series\n",
                "    if is_anat:\n",
                "        series = PAR_SERIES_ANAT[par]\n",
                "    else:\n",
                "        series = PAR_SERIES_FUNC[par][run]\n",
                "\n",
                "    #search\n",
                "    search = f\"{directory}{prefix}{ID}-{series:04}-*.dcm\"\n",
                "    files = glob.glob(search, recursive=True)\n",
                "    if not len(files):\n",
                "        #sometimes space after ID\n",
                "        search = f\"{directory}{prefix}{ID} -{series:04}-*.dcm\"\n",
                "        files = glob.glob(search, recursive=True)    \n",
                "\n",
                "        if not len(files):\n",
                "            #if still nothing, try the non-standard format\n",
                "            search = f\"{directory}{prefix}{ID}.*.{series:04}.*.*.*.dcm\"\n",
                "            files = glob.glob(search, recursive=True)\n",
                "    \n",
                "    #return result\n",
                "    return files\n",
                "    \n",
                "    \n",
                "\n",
                "########################################################################################################\n",
                "######################################## Display Valid Sub/Run #########################################\n",
                "########################################################################################################\n",
                "\n",
                "print('Subjects and runs to process:')\n",
                "for par in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "    if PAR_TO_DO[par]:\n",
                "        print(f\"\\t{PAR_NAMES[par]} = {PAR_ID[par]}\")\n",
                "        if ANAT_TO_DO[par]:\n",
                "            series = f\"{PAR_SERIES_ANAT[par]:02}\"\n",
                "        else:\n",
                "            series = \"skip\"\n",
                "        print(f\"\\t\\tanatomical series  = {series}\")\n",
                "        for run in range(0,MAX_NUMBER_RUNS):\n",
                "            #stop early if no more to run\n",
                "            if not any(FUNC_TO_DO[par,run:]):\n",
                "                break;\n",
                "\n",
                "            if FUNC_TO_DO[par,run]:\n",
                "                series = f\"{PAR_SERIES_FUNC[par,run]:02}\"\n",
                "            else:\n",
                "                series = \"skip\"\n",
                "            print(f\"\\t\\tfunc run {run+1:02} series = {series}\")\n",
                "\n",
                "print('Preparations complete. You can now run any of the later cells.')"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "# Create Anonymous DICOM Set\n",
                "1. Copy DICOM files from input folder to output folder (manual reorder)\n",
                "1. Remove original participant IDs (switch to sub-##)\n",
                "1. (Optional) Confirm number of files"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 65,
            "metadata": {
            },
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "Copy DICOMs (manual reorder), rename to remove original IDs, and confirm number of files...\n",
                        "Processing sub-01...\n",
                        "\tanat series 0009\n",
                        "\t\talready complete\n",
                        "\tfunc1 series 0006\n",
                        "\t\tcopying...\n",
                        "\t\tremove participant IDs...\n",
                        "\tfunc2 series 0012\n",
                        "\t\tcopying...\n",
                        "\t\tremove participant IDs...\n",
                        "Complete."
                    ]
                }
            ],
            "source": [
                "print(\"Copy DICOMs (manual reorder), rename to remove original IDs, and confirm number of files...\")\n",
                "for par in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "    if PAR_TO_DO[par]:\n",
                "        print(f\"Processing {PAR_NAMES[par]}...\")\n",
                "        for i in range(0,SERIES_TO_DO_COUNT[par]):\n",
                "            series = SERIES_TO_DO[par][i];\n",
                "            is_anat = SERIES_TO_DO_IS_ANAT[par][i];\n",
                "            run = SERIES_TO_DO_RUN[par][i];\n",
                "            \n",
                "            #type\n",
                "            if is_anat:\n",
                "                type = \"anat\"\n",
                "                run = -1\n",
                "                directory = SUBDIR_DICOM_ANAT[par]\n",
                "            else:\n",
                "                type = f\"func{run+1}\"\n",
                "                directory = SUBDIR_DICOM_FUNC[par][run]\n",
                "            print(f\"\\t{type} series {series:04}\")\n",
                "            \n",
                "            #make output directory if needed\n",
                "            if not path.isdir(directory):\n",
                "                os.makedirs(directory)\n",
                "\n",
                "            #expected number of files\n",
                "            if is_anat:\n",
                "                expected = EXPECTED_NUMBER_FILES_ANAT\n",
                "            else:\n",
                "                expected = EXPECTED_NUMBER_FILES_FUNC\n",
                "            compare_to_expected = expected>0\n",
                "            \n",
                "            #files input\n",
                "            files_input = GetDICOMS(par, run, is_anat, True, False, False)\n",
                "            number_files_input = len(files_input)\n",
                "            \n",
                "            #files final\n",
                "            number_files_final = max( len(GetDICOMS(par, run, is_anat, False, True, False)) , len(GetDICOMS(par, run, is_anat, False, True, True)) )\n",
                "            \n",
                "            #already done?\n",
                "            if ((number_files_input == number_files_final) & (number_files_input > 0)) | ((number_files_input==0) & (number_files_final>0)):\n",
                "                print(\"\\t\\talready complete\")\n",
                "            else:\n",
                "                #one or more steps needed...copy and/or anon\n",
                "                \n",
                "                #check number input files\n",
                "                if number_files_input>0:\n",
                "                    if compare_to_expected & (number_files_input != expected):\n",
                "                        raise Exception(f\"{PAR_NAMES[par]}, series {series:04}: number of input files ({number_files_input}) does not match expected ({expected})\")\n",
                "\n",
                "                #need to copy?\n",
                "                number_files_copied_but_not_yet_anon = len(GetDICOMS(par, run, is_anat, False, False, False))\n",
                "                if (number_files_copied_but_not_yet_anon == number_files_input) & (number_files_input == 0):\n",
                "                    raise Exception(f\"{PAR_NAMES[par]}, {type} series {series:04}: no input files to copy\")\n",
                "                if number_files_copied_but_not_yet_anon < number_files_input:\n",
                "                    print(\"\\t\\tcopying...\")\n",
                "                    files_output = [f\"{directory + ntpath.basename(file)}\" for file in files_input]\n",
                "                    for f in range(0, number_files_input):\n",
                "                        shutil.copyfile(files_input[f], files_output[f])\n",
                "                        \n",
                "                #remove participant IDs\n",
                "                print(\"\\t\\tremove participant IDs...\")\n",
                "                bv.anonymize_dicoms(directory, PAR_NAMES[par])\n",
                "                        \n",
                "                #number output files\n",
                "                number_files_final = len(GetDICOMS(par, run, is_anat, False, True, False));\n",
                "            \n",
                "            #check number output files\n",
                "            if compare_to_expected & (number_files_final != expected):\n",
                "                raise Exception(f\"{PAR_NAMES[par]}, {type} series {series:04}: number of output files ({number_files_final}) does not match expected ({expected})\")\n",
                "                \n",
                "            #should always be some output files regardless of expected\n",
                "            if number_files_final == 0:\n",
                "                raise Exception(f\"{PAR_NAMES[par]}, {type} series {series:04}: no output files\")\n",
                "\n",
                "print('Complete.')"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "# (Optional) Deface Anatomical Dicoms\n",
                "Remove the face from anatomical dicoms so that it cannot be reconstructed to identify particiapnts."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 59,
            "metadata": {
            },
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "Defacing anatomical dicoms...\n",
                        "Processing sub-01...\n",
                        "\trunning...\n",
                        "Complete."
                    ]
                }
            ],
            "source": [
                "print(\"Defacing anatomical dicoms...\")\n",
                "if (not DEFACE_ANAT):\n",
                "    print('DEFACE_ANAT is false, skipping this step')\n",
                "else:\n",
                "    for par in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "        if PAR_TO_DO[par]:\n",
                "            print(f\"Processing {PAR_NAMES[par]}...\")\n",
                "            anat_files = GetDICOMS(par, -1, True, False, True, False)\n",
                "            deface_files = GetDICOMS(par, -1, True, False, True, True)\n",
                "            anat_files_count = len(anat_files)\n",
                "            deface_files_count = len(deface_files)\n",
                "            \n",
                "            #check existing files\n",
                "            if ((anat_files_count>0) & (anat_files_count == deface_files_count)) | ((anat_files_count<=0) & (deface_files_count > 0)):\n",
                "                #already done, just check number of files\n",
                "                if (EXPECTED_NUMBER_FILES_ANAT>0) & (deface_files_count != EXPECTED_NUMBER_FILES_ANAT):\n",
                "                    raise Exception(f\"Deface appears to be complete for {PAR_NAMES[par]} but the number of files ({deface_files_count}) is not unexpected ({EXPECTED_NUMBER_FILES_ANAT})\")\n",
                "                else:\n",
                "                    print(\"\\talready complete\")\n",
                "                    continue\n",
                "                    \n",
                "            #need to run...\n",
                "            \n",
                "            #check input\n",
                "            if anat_files_count < 1:\n",
                "                raise Exception(f\"Deface need to be run for {PAR_NAMES[par]} but no files were found for anon anat\")\n",
                "            elif (EXPECTED_NUMBER_FILES_ANAT>0) & (anat_files_count != EXPECTED_NUMBER_FILES_ANAT):\n",
                "                raise Exception(f\"Deface need to be run for {PAR_NAMES[par]} but the number of files for anon anat ({anat_files_count}) is not expected ({EXPECTED_NUMBER_FILES_ANAT})\")\n",
                "\n",
                "            #remove any incomplete deface_files dicom files from before\n",
                "            if deface_files_count > 0:\n",
                "                print(\"\\t\\tfound incomplete deface files, deleting...\")\n",
                "                for fp in deface_files:\n",
                "                    os.remove(fp)\n",
                "\n",
                "            #run\n",
                "            print(\"\\trunning...\")\n",
                "            success = bv.deface_anat_dicoms(SUBDIR_DICOM_ANAT[par], SUBDIR_DICOM_ANAT[par])\n",
                "            \n",
                "            #success?\n",
                "            if not success:\n",
                "                raise Exception(f\"Deface failed for {PAR_NAMES[par]}\")\n",
                "            \n",
                "print('Complete.')    "
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "# Deface Cleanup\n",
                "Remove leftover files after defacting. Also confirms whether all participants were defaced when defacing is enabled."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 60,
            "metadata": {
            },
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "Deleting leftover files after defacing...\n",
                        "Processing sub-01...\n",
                        "\t\tDeleting leftover file: C:/Users/CulhamLabTR/Desktop/Marisa/Dicoms/PIL04 - 20211018/DICOM_Anon/sub-01/anat/defaced.vmr\n",
                        "\t\tDeleting leftover file: C:/Users/CulhamLabTR/Desktop/Marisa/Dicoms/PIL04 - 20211018/DICOM_Anon/sub-01/anat/defaced.v16\n",
                        "\t\tDeleting pre-deface anatomical dicoms...\n",
                        "Complete."
                    ]
                }
            ],
            "source": [
                "print(\"Deleting leftover files after defacing...\")\n",
                "for par in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "    if PAR_TO_DO[par]:\n",
                "        print(f\"Processing {PAR_NAMES[par]}...\")\n",
                "        contains_deface_files = len(GetDICOMS(par, -1, True, False, True, True)) > 0\n",
                "        if (not DEFACE_ANAT) & contains_deface_files:\n",
                "            raise Exception(f\"Unexpected deface files found in {SUBDIR_DICOM_ANAT[par]}\")\n",
                "        elif (DEFACE_ANAT) & (not contains_deface_files):\n",
                "            raise Exception(f\"No deface files found in {SUBDIR_DICOM_ANAT[par]}\")\n",
                "        else:\n",
                "            #remove unneeded files after deface\n",
                "            for fn in [\"defaced.vmr\" , \"defaced.v16\"]:\n",
                "                fp = SUBDIR_DICOM_ANAT[par]+fn\n",
                "                if path.isfile(fp):\n",
                "                    print(f\"\\t\\tDeleting leftover file: {fp}\") \n",
                "                    os.remove(fp)\n",
                "            dicoms_prior = GetDICOMS(par, -1, True, False, True, False)\n",
                "            if len(dicoms_prior) > 0:\n",
                "                print(\"\\t\\tDeleting pre-deface anatomical dicoms...\")\n",
                "                for fp in dicoms_prior:\n",
                "                    os.remove(fp)\n",
                "\n",
                "print('Complete.')    "
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "# Create Anonymous PRT/TSV Set\n",
                "Creates renamed copy of event files to attach to BIDS."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 66,
            "metadata": {
            },
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "Creating anonymous set of event files...\n",
                        "Processing sub-01...\n",
                        "Complete."
                    ]
                }
            ],
            "source": [
                "print(\"Creating anonymous set of event files...\")\n",
                "\n",
                "#make output directory if needed\n",
                "if not path.isdir(DIRECTORY_OUTPUT_EVENTS):\n",
                "    os.makedirs(DIRECTORY_OUTPUT_EVENTS)\n",
                "\n",
                "for par in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "    if PAR_TO_DO[par]:\n",
                "        print(f\"Processing {PAR_NAMES[par]}...\")\n",
                "        for run in range(0,MAX_NUMBER_RUNS):\n",
                "            if FUNC_TO_DO[par][run]:        \n",
                "                if not path.isfile(FILEPATH_EVENT_ANON[par][run]):\n",
                "                    #find source file\n",
                "                    if not isinstance(PAR_EVENT_FILENAMES[par][run], str):\n",
                "                        number_files = 0\n",
                "                    else:\n",
                "                        search = DIRECTORY_INPUT_EVENTS + \"**/\" + PAR_EVENT_FILENAMES[par][run]\n",
                "                        files = glob.glob(search, recursive=True)\n",
                "                        number_files = len(files)\n",
                "                    if (number_files < 1):\n",
                "                        if REQUIRE_FUNC_EVENTS:\n",
                "                            raise Exception(f\"Could not locate event file {PAR_EVENT_FILENAMES[par][run]} (for {PAR_NAMES[par]} functional run {run+1})\")\n",
                "                        else:\n",
                "                            print(f\"\\tWARNING: no event file for {PAR_NAMES[par]} functional run {run+1}\")\n",
                "                    else:\n",
                "                        if number_files > 1:\n",
                "                            raise Exception(f\"More than one match found for file {PAR_EVENT_FILENAMES[par][run]} (for {PAR_NAMES[par]} functional run {run+1})\")\n",
                "                        else:\n",
                "                            shutil.copyfile(files[0], FILEPATH_EVENT_ANON[par][run])\n",
                "print('Complete.') "
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "# Convert to BIDS\n",
                "Also links event file if there is one."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 67,
            "metadata": {
            },
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "Creating BIDS fileset...\n",
                        "Processing sub-01...\n",
                        "Complete."
                    ]
                }
            ],
            "source": [
                "print(\"Creating BIDS fileset...\")\n",
                "for par in range(0,MAX_NUMBER_PARTICIPANTS):\n",
                "    if PAR_TO_DO[par]:\n",
                "        print(f\"Processing {PAR_NAMES[par]}...\")\n",
                "        \n",
                "        #1. anat\n",
                "        if ANAT_TO_DO[par]:\n",
                "            filepath = DIRECTORY_OUTPUT_BIDS + PAR_NAMES[par] + \"/ses-01/anat/\" + PAR_NAMES[par] + \"_ses-01_T1w.nii.gz\"\n",
                "            if not path.isfile(filepath):\n",
                "                files = GetDICOMS(par, -1, True, False, True, DEFACE_ANAT)\n",
                "                if len(files) < 1:\n",
                "                    raise Exception(f\"Could not locate DICOM files for {PAR_NAMES[par]} anatomical\")\n",
                "                else:\n",
                "                    number_files = len(files)\n",
                "                    if (EXPECTED_NUMBER_FILES_ANAT > 0) & (EXPECTED_NUMBER_FILES_ANAT != number_files):\n",
                "                        raise Exception(f\"Unexpected number of files ({number_files}) for {PAR_NAMES[par]} anatomical ({EXPECTED_NUMBER_FILES_ANAT})\")         \n",
                "\n",
                "                    file = files[0].replace(\"\\\\\", \"/\")\n",
                "                    success = bv.create_vmr_dicom_nifti_bids(file, par+1, 1, DIRECTORY_OUTPUT_BIDS)\n",
                "                    if len(success) < 1:\n",
                "                        raise Exception(f\"Failed to create BIDS for {PAR_NAMES[par]} anatomical\")\n",
                "        \n",
                "        #2. func runs\n",
                "        for run in range(0, MAX_NUMBER_RUNS):\n",
                "            if FUNC_TO_DO[par][run]:\n",
                "                filepath = DIRECTORY_OUTPUT_BIDS + PAR_NAMES[par] + \"/ses-01/func/\" + PAR_NAMES[par] + \"_ses-01_task-\" + TASK_NAME + f\"_run-{run+1:02}_bold.nii.gz\"\n",
                "                if not path.isfile(filepath):\n",
                "                    files = GetDICOMS(par, run, False, False, True, False)\n",
                "                    if len(files) < 1:\n",
                "                        raise Exception(f\"Could not locate DICOM files for {PAR_NAMES[par]} functional run {run+1}\")\n",
                "                    else:\n",
                "                        number_files = len(files)\n",
                "                        if (EXPECTED_NUMBER_FILES_FUNC > 0) & (EXPECTED_NUMBER_FILES_FUNC != number_files):\n",
                "                            raise Exception(f\"Unexpected number of files ({number_files}) for {PAR_NAMES[par]} functional run {run+1} ({EXPECTED_NUMBER_FILES_ANAT})\")   \n",
                "\n",
                "                        file = files[-1].replace(\"\\\\\", \"/\")\n",
                "                        if not path.isfile(FILEPATH_EVENT_ANON[par][run]):\n",
                "                            if REQUIRE_FUNC_EVENTS:\n",
                "                                raise Exception(f\"Could not locate event file {PAR_EVENT_FILENAMES[par][run]} (for {PAR_NAMES[par]} functional run {run+1})\")\n",
                "                            else:\n",
                "                                print(f\"\\tWARNING: no event file linked to {filepath}\")\n",
                "                                success = bv.create_fmr_dicom_nifti_bids(file, par+1, 1, run+1, TASK_NAME, DIRECTORY_OUTPUT_BIDS)\n",
                "                        else:                            \n",
                "                            success = bv.create_fmr_dicom_nifti_bids(file, par+1, 1, run+1, TASK_NAME, DIRECTORY_OUTPUT_BIDS, FILEPATH_EVENT_ANON[par][run])\n",
                "                        \n",
                "                        if len(success) < 1:\n",
                "                            raise Exception(f\"Failed to create BIDS for {PAR_NAMES[par]} functional run {run+1}\")\n",
                "        \n",
                "print('Complete.') "
            ]
        },
        {
            "cell_type": "code",
            "execution_count": -1,
            "metadata": {
            },
            "outputs": [
            ],
            "source": [
            ]
        }
    ],
    "log_brainvoyager_code": false,
    "metadata": {
    }
}
